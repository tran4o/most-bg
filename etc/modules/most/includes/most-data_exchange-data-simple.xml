<?xml version="1.0" encoding="UTF-8"?>
<import revision="$LastChangedRevision: 18817 $" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:vsl="http://www.plan-vision.com/VSL/1.0">
<objects>
<!-- core.data_import_xls:4096|row_filter_script|core.vscript:2062848|params| -->
<object code="row" objectdef="script_param" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <is_hidden>
      <value>false</value>
   </is_hidden>
</object>
<!-- core.data_import_xls:4096|row_filter_script|core.vscript:2062848|params| -->
<object code="lines" objectdef="script_param" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <is_hidden>
      <value>false</value>
   </is_hidden>
</object>
<!-- core.data_import_xls:4096|row_filter_script|core.vscript:2062848|params| -->
<object code="nameToCol" objectdef="script_param" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <is_hidden>
      <value>false</value>
   </is_hidden>
</object>
<!--  -->
<object code="most:pl2group" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <en-US>MOST Product Line to Product Group</en-US>
         <bg-BG>MOST отношение групи към продуктови линии</bg-BG>
     </value>
   </name>
   <description>
    <value>
        <en-US>        
        <![CDATA[<%
    
File format for import

0 : family id
1 : product line
2 : category
3 : pl desc
4 : family desc

         %>]]>
        </en-US>
    </value>
   </description>
   <template>
       <value><![CDATA[<%
      
//0 : family id
//1 : product line
//2 : category
//3 : pl desc
//4 : family desc

var row = DATA_ORDERED;
var plcode = row[1];
var catcode = row[2];

if (catcode.length()) {
    catcode = catcode.castToInexactNumber().castToExactNumber();
}

var pl = db.most.product_line.INSTANCES[plcode];

if (pl==null) {
  warn("pl not found: " + pl);
  return;
} else {
  info("pl found: " + pl);
}

var cat = db.most.product_group.INSTANCES[catcode.castToString()];

if (cat==null) {
  warn("category not found: " + catcode);
  return;
} else {
  info("pl found: " + catcode);
}

pl.product_group = cat;
// pl.family_id = row[0];
// pl.family_desc = row[4];
pl.name = row[3];
pl.commit();

           %>]]>
           </value>
   </template>
   <header_row>
      <value>0</value>
   </header_row>
   <is_use_events>
      <value>true</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>JmwQmr8HSuqaHlh6dYHI4Q</value>
   </uuid>
</object>
<!--  -->
<object code="most:import_opg_from_hp" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <en-US>HP OPG Import from .TSV(TXT)</en-US>
         <bg-BG>HP OPG внос от текстов файл .TSV(TXT)</bg-BG>
         </value>
   </name>
   <template>
       <value><![CDATA[
    <%
	      
	//0 : may be a part of the OPG Desc or "Product Number: line"
	//    https://regex101.com/r/dT6cA1/1

	var opg = session.attributes["last_opg_import"];
	var row = DATA_ORDERED;
	var what = row[0];
    var mc2type = new M();
    mc2type["7"] = "U";
    mc2type["07"] = "U";
    mc2type["72"] =  "U";
    mc2type["77"] =  "U";
    mc2type["78"] =  "U";
    mc2type["09R"] =  "R";
    mc2type["26R"] =  "R";
    mc2type["26R"] =  "R";
    mc2type["27R"] =  "R";
    mc2type["69T"] =  "R";
    mc2type["72G"] =  "M";
    mc2type["72M"] =  "M";
    mc2type["72R"] =  "R";
    mc2type["77E"] =  "M";
    mc2type["77R"] =  "R";
    mc2type["78E"] =  "M";
    mc2type["78R"] =  "R";
    mc2type["A9R"] =  "R";
    mc2type["A9U"] =  "U";

	function CREATE_OPG(d) {
		if (db.most.opg.INSTANCES[d]) {
			info("this opg already exists. overwriting: " + d);
			opg = db.most.opg.INSTANCES[d];
		} else {
			info("creating new opg: " + d);
			opg = new db.most.opg();
			opg.code = d;
			opg.discount_mode = "U";
		}

		opg.import_time = java.date.today();
		session.attributes["last_opg_import"] = opg;
		return d;
	}

	function PARSE_OPGDATE(d) {
		if (d.indexOf("/") >= 0) {
            var s = d.substring(0,6) + "20" + d.substring(6);
            s = s.replace("/", ".");
            info(s);
		 	return java.date.parse("dd.MM.yyyy", s);
		} else {
			return java.date.parse("yyyy-MM-dd", d);
		}
	}

	function PARSE_OPGDETAIL() {
		var pl = db.most.product_line.INSTANCES[row[4]];
		var article = db.most.article.INSTANCES[row[1]];

		if (article == undefined) {
			error("missing article. creating with PL only.");
			article = new db.most.article();
			article.code = row[1];
			article.product_line = pl;
			article.description = row[3];
		}

		var exist = SDATA(opg, "entries", "entries.article.id='" + article.id + "'");
		var cdet;

		if (exist != null) {
			cdet = exist;
			info("found existing  entry for: " + article.code);
	 	} else {
		 	db.most.opg_entry();
			info("create opg entry for: " + article.code);
	 	}
		
		cdet.article = article;
		cdet.max_quantity = row[6];
		cdet.value = PARSE_DOUBLE(row[9]);
		cdet.commit();


		opg.entries << cdet;
		opg.commit();
	}
    
    function PARSE_DISCOUNT_MODE(d) {
        var dmode = mc2type[d.castToString()];
        if (dmode) {
            info("resolved MC code " + d + " to discount mode: " + dmode);
            return dmode;
        } else { 
            warn("could not resolve MC code to discount mode: " + d);
            return "U";
        }        
    }

	var action = new M();
    
	action["MC Code"] = ["discount_mode", 2, PARSE_DISCOUNT_MODE];
	action["Deal Number"] = ["code", 2, CREATE_OPG];
	action["Deal Description"] = ["description", 2, null];
	action["Order From"] = ["valid_from", 2, PARSE_OPGDATE],
	action["Order To"] = ["valid_to", 2, PARSE_OPGDATE],
	action["Deal Version"] = ["version", 2, PARSE_INTEGER],
	action["Product Number"] = [null, null, PARSE_OPGDETAIL];

	for (var text: action.keys) {
		if (row[0].indexOf(text) == 0) {
			info(text + " MATCHED");

			var prop = action[text][0];
			var pos = action[text][1];
			var fn = action[text][2];

			if (prop == null) {
				fn();	
			} else {
				if ( fn != null ) {				
					opg[prop] = fn(row[pos]);
				} else {
					opg[prop] = row[pos];
				}
    			info("setting property [" + prop + "] to [" + opg[prop] + "]");
			}
		} 
	}

	%>	    
    
   ]]></value>
   </template>
   <header_row>
      <value>0</value>
   </header_row>
   <is_use_events>
      <value>true</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>crPIYMNSRWCeKBTiYHOv6Q</value>
   </uuid>
</object>
<!--  -->
<object code="most:sales" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <bg-BG>MOST продажби</bg-BG></value>
   </name>
  <description>
    <value>
        <en-US>
        
        <![CDATA[<%
    
File format for import
      
0 : most_sale_id
1 : BID (CUSTOMER abbreviation)
2 : CUSTOMER NAME
3 : CSTID (NOT USED)
4 : TID (NOT USED)
5 : CFGSUBTYPE -> HARDCORE PARSE FUCK FOR PRODUCT ID
6 : SDATE (yyyy-MM-dd)
7 : most_order_id
8 : QTY
9 : SALEPRICE = Price_EUR (most_sale_price in schema - tam e BGN)
10 : BULSTAT 
11 : m0_price
 
         %>]]>

        </en-US>
    </value>
   </description>
 
   <template>
      <value><![CDATA[<%
      
//0 : most_sale_id
//1 : BID (CUSTOMER abbreviation)
//2 : CUSTOMER NAME
//3 : CSTID (NOT USED)
//4 : TID (NOT USED)
//5 : CFGSUBTYPE -> HARDCORE PARSE FUCK FOR PRODUCT ID
//6 : SDATE (yyyy-MM-dd)
//7 : most_order_id
//8 : QTY
//9 : SALEPRICE = Price_EUR (most_sale_price in schema - tam e BGN)
//10 : BULSTAT 
//11 : m0_price
      
var MOST_SALE_ID = DATA_ORDERED[0];
var BID = DATA_ORDERED[1];
var CFGSUBTYPE = DATA_ORDERED[5];
var SDATE = DATA_ORDERED[6];
var MOST_ORDER_ID = DATA_ORDERED[7];
var QTY = DATA_ORDERED[8];
var MOST_SALE_TOTAL = DATA_ORDERED[9];		// SALE_PRICE = Price_EUR
var M0_PRICE = DATA_ORDERED[11];

var SDATE = java.date.parse("yyyy-MM-dd",SDATE);
var rdate = db.most.protocol_date.INSTANCES[java.date.format("dd.MM.yyyy",SDATE)];

if (BID == null || BID == "") {
	error("Empty BID provieded");
} else {
	var x = db.most.customer.SELECT("abbreviation = :ABID");
	x["ABID"]=BID;
	x.is_cached=false;
	if (x.size > 1) {
		error("Many COMPANIES found (>1) with BID="+BID);
	} else {
		var customer;
		if (x.is_empty) {
			warn("Customer with BID (abbreviation) "+BID+" NOT FOUND. Creating...");
			customer=new db.most.customer();
			customer.abbreviation=BID;
		} else {
			customer=x[0];
		}
		//----------------------	
		var artcode;
		if (CFGSUBTYPE.indexOf(" ") < 0) {
			artcode=CFGSUBTYPE;
		} else {
			artcode=CFGSUBTYPE.substring(0,CFGSUBTYPE.indexOf(" "));
		}
		var article=db.most.article.INSTANCES[artcode];
		if (article == null) {
			info("Can not find article with CODE="+artcode+" | Creating...");
			article = new db.most.article();
			article.code=artcode;
			article.commit();
		}
		if (QTY == 0) {
			error("Can not import article with CODE="+artcode+" AND QUANTITY : "+QTY);
		} else {
			var sale=null;
			//-----------------------------------
			// rdate > real_date
			// customer > customer
			var kk = db.most.protocol_sale.SELECT("most_sale_id = :MID");
			kk["MID"]=MOST_SALE_ID;
			kk.is_cached=false;
			if (kk.size > 1) {
				error("Many SALES found (>1) with most_sale_id="+MOST_SALE_ID);
			} else {
				if (kk.size == 1)
					sale=kk[0];
				//-----------------------------------
				if (sale == null) 
					sale = new db.most.protocol_sale();
				sale.quantity=QTY;
				sale.customer=customer;
				sale.article=article;
				sale.most_sale_id=MOST_SALE_ID;
				sale.most_sale_total=MOST_SALE_TOTAL.castToInexactNumber() / 1.95583;
				sale.m0_price=M0_PRICE.castToInexactNumber() / 1.95583;	
				sale.most_order_id=MOST_ORDER_ID;		
				sale.commit();
				sale.real_date = rdate;
				sale.commit();
				//-----------------------------------
				// info((count+1)+" DONE : "+OBJSTR(customer)+" | "+OBJSTR(artcode)+" | "+rdate+" | "+sale.most_sale_total);
			} 
		}
	}
}
%>	]]></value>
   </template>
   <header_row>
      <value>0</value>
   </header_row>
   <is_use_events>
      <value>true</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>0M_I2P4aRF-zK4emBtEE6g</value>
   </uuid>
   <row_filter_script>
      <value>
		<object mode="update" code="most.import_sales.xls.filter-script" objectdef="vscript" module="core" /></value>
   </row_filter_script>
</object>
<!--  -->
<object code="most.odit" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <bg-BG>MOST ревизия</bg-BG></value>
   </name>
   <template>
      <value><![CDATA[<%
    var TTT = db.most.protocol.TEMP;
    var prodId = DATA["ProdNo"];    
    var article = db.most.article.INSTANCES[prodId];
    if (article == null) {
    	var cc = TTT["cc"];
		if (cc == null)
			cc=0;
		cc++;
		TTT["cc"]=cc;
        java.log.error("Article "+prodId+" NOT FOUND ("+cc+")");
	} else {
		var hp = DATA["HP"].castToExactNumber();
		var most = DATA["MOST"].castToExactNumber();
		if (hp < 0)
			hp=0;
		if (most < 0) 
			most = 0;
		var date = db.most.protocol_date.INSTANCES[java.date.format("dd.MM.yyyy",java.date.now())];
		var sel = db.most.odit.SELECT("\"date\" = :DID");
		sel["DID"]=date.id;
		var e;
		if (TTT["done"]== null) 
		{
			for (e : sel) 
			{		
				e.delete();
				e.commit();
			}
			e = new db.most.odit();
			e.date=date;
			e.code=date.code;
			e.name["en-US"]="XLS imported odit "+date.code;
			e.name["bg-BG"]="Ревизия от XLS "+date.code;
			TTT["done"].reset(e);
		} else {
			e=TTT["done"];
		}
		var en = new db.most.odit_entry();
		en.on_stock_reported=hp;
		en.on_stock=most;
		en.odit=e;
		en.article=article;
		e.commit();
		en.commit();
	}
%>]]></value>
   </template>
   <is_use_events>
      <value>true</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>1bnsErWRSgeiNepb2BF6uQ</value>
   </uuid>
</object>
<!--  -->
<object code="HP STOCKS XLS" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <en-US>MOST stocks from XLS</en-US></value>
   </name>
   <template>
      <value><![CDATA[<%
var PID = DATA["Part No"];
var QTY = DATA["Qty HP"];
var PRC = DATA["Euro"];
var x = db.most.article.INSTANCES[PID];
if (x == null || QTY == null || PRC == null) {
    java.log.error("CAN NOT FIND ARTICLE WITH CODE="+PID);
} else {
    var article = x;
    var key = "XLS"+PID;
    var stock = db.most.protocol_stock[key];
    if (stock == null) {
        stock=new db.most.protocol_stock();
        stock.code=key;
	}
	stock.article=article;
	stock.real_date=db.most.protocol_date.INSTANCES["01.01.2015"];
	stock.official_date=db.most.protocol_date.INSTANCES["01.01.2015"];
	stock.price=PRC;
	stock.quantity=QTY;        
}
%>	]]></value>
   </template>
   <is_use_events>
      <value>true</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>qwHJ8FCrS8SbEKeUHT40Xg</value>
   </uuid>
</object>
<!-- core.data_import_xls:4096|row_filter_script| -->
<object code="most.import_companies.xls.filter-script" objectdef="vscript" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <script_code>
      <value><![CDATA[
//lines,row,nameToCol
var line = lines[row];
var colBid = nameToCol["Bid"];
var colCmp = nameToCol["Име на фирма"];
var colBul = nameToCol["Булстат"];
if (line[colCmp] == null || line[colCmp].trim() == "")
	return false;
try {
    line[colBid].castToExactNumber();    
} catch(e) {
    return false;
}
return true;                        
         ]]></value>
   </script_code>
   <params mode="update">
      <value sort_id="0"><!-- core.data_import_xls:4096|row_filter_script|core.vscript:2062848|params| -->
<object mode="update" code="lines" objectdef="script_param" module="core" /></value>
      <value sort_id="0"><!-- core.data_import_xls:4096|row_filter_script|core.vscript:2062848|params| -->
<object mode="update" code="row" objectdef="script_param" module="core" /></value>
      <value sort_id="0"><!-- core.data_import_xls:4096|row_filter_script|core.vscript:2062848|params| -->
<object mode="update" code="nameToCol" objectdef="script_param" module="core" /></value>
   </params>
   <is_autostart>
      <value>false</value>
   </is_autostart>
   <is_hidden>
      <value>false</value>
   </is_hidden>
   <is_supports_mobile>
      <value>false</value>
   </is_supports_mobile>
</object>
<!--  -->
<object code="most:companies" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <bg-BG>MOST компании</bg-BG></value>
   </name>
   <data_file>
      <value><object mode="update" code="All-Companies.xls" objectdef="file" module="documents" cond="&quot;parent&quot;.&quot;code&quot; = 'initial' AND &quot;parent&quot;.&quot;parent&quot;.&quot;code&quot; = 'most' AND &quot;parent&quot;.&quot;parent&quot;.&quot;parent&quot;.&quot;code&quot; = '/' AND &quot;parent&quot;.&quot;parent&quot;.&quot;parent&quot;.&quot;parent&quot; IS NULL"/></value>
   </data_file>
   <template>
      <value><![CDATA[<object cond="abbreviation='${Bid}'" module="most" objectdef="customer">
    <code><value>${Булстат}</value></code>
	<abbreviation>
	<value>${Bid}</value>
	</abbreviation>
	<name>
		<value><en-US><%= SCRIPTS["gen.bg2lat"](DATA["Име на фирма"]) %></en-US></value> 
		<value><bg-BG>${Име на фирма}</bg-BG></value> 
	</name>
	<contact_types mode="update">
		<value>
			<object module="contacts" objectdef="contact_type" code="customer" mode="update">
			</object>
		</value>
	</contact_types>
</object>
]]></value>
   </template>
   <row_filter_script>
      <value><!-- core.data_import_xls:4096|row_filter_script| -->
<object mode="update" code="most.import_companies.xls.filter-script" objectdef="vscript" module="core" /></value>
   </row_filter_script>
   <is_use_events>
      <value>false</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>W2VC7S6uR_-lRkTG6nJqwQ</value>
   </uuid>
</object>
<!--  -->
<object code="PRODUCT LINE MIGRATION" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <en-US>Migrate product line after update </en-US></value>
   </name>
   <data_file>
      <value><object mode="update" code="PROD-PL-04122015.xls" objectdef="file" module="documents" cond="&quot;parent&quot;.&quot;code&quot; = 'initial' AND &quot;parent&quot;.&quot;parent&quot;.&quot;code&quot; = 'most' AND &quot;parent&quot;.&quot;parent&quot;.&quot;parent&quot;.&quot;code&quot; = '/' AND &quot;parent&quot;.&quot;parent&quot;.&quot;parent&quot;.&quot;parent&quot; IS NULL"/></value>
   </data_file>
   <template>
      <value><![CDATA[<object code="${CODE}" module="most" objectdef="article">
    <product_line>
		<value>
			<object module="most" objectdef="product_line" code="${PL}"/>
		</value>
	</product_line>
</object>
]]></value>
   </template>
   <is_use_events>
      <value>false</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>N3omIB1RRQq7DfoVdiEvGA</value>
   </uuid>
</object>
<!--  -->
<object code="most:import_invoice_from_hp" objectdef="data_import_xls" module="core" >
   <sort_id>
      <value>0</value>
   </sort_id>
   <name>
      <value>
         <en-US>HP Invoice import from XLS</en-US>
         <bg-BG>HP фактура внос от XLS</bg-BG>
      </value>
   </name>
   <description>
      <value>
         <en-US>
<![CDATA[
the file should have these columns : 

0 - purchase order number
1 - invoice date
2 - invoice number
3 - net invoice price
4 - item price (real number)
5 - deal id for item (OPG)
6 - bundle id
7 - article code (product part number)
8 - serial number
11 - quantity (integer)
12 - product line (as code in system)
13 - vendor (code as in system, i.e. HPE, HPI)
]]>
</en-US></value>
   </description>
   <template>
      <value><![CDATA[<%

/*global session, DATA_ORDERED, SDATA, PARSE_INTEGER, PARSE_DOUBLE */
/*global info, error, db, java */
/*eslint new-cap: [0] */
/*eslint quotes: [2, "double"]*/

var row = DATA_ORDERED;
var purchase_order_no = row[0];
var invoice_date = row[1];
var invoice_no = row[2];
var net_invoice_price = row[3];
var price = row[4];
var deal_id = row[5];
var bundle_id = row[6];
var article_code = row[7];
var serial_number = row[8];
var quantity = row[11];
var product_line = row[12];
var vendor = row[13];

price = price.replace(".", ",");
purchase_order_no = purchase_order_no.replace("-" + deal_id, "");

var invoice_code = invoice_no.castToString();
while (invoice_code.length() < 10 ) {
    invoice_code = "0" + invoice_code;
}
invoice_code = "INV" + invoice_code;

if (PARSE_INTEGER(quantity) == null) {
    return false;    
}

function PARSE_OPGDATE(d) {
    if (d.indexOf("/") >= 0) {
        var s = d.substring(0,6) + "20" + d.substring(6);
        s = s.replace("/", ".");
        info(s);
         return java.date.parse("dd.MM.yyyy", s);
	} else {
		return java.date.parse("yyyy-MM-dd", d);
	}
}

function prod_find_or_create(code, name, product_line, description, vendor) {
    //trim code
    if ( code.indexOf("#") > 0 ) {
        code = code.substring(0, code.indexOf("#"));
    }

    var artobj = db.most.article.INSTANCES[code];

    if (artobj != null) {
        info("product " + code + " found. vendor is " + vendor);
    } else {
        info("product " + code + " not found. new instance. vendor is " + vendor);
        artobj = new db.most.article();
    }

    vendor = db.contacts.vendor.INSTANCES[vendor];
    if ( vendor == null ) {
        vendor = db.contacts.vendor.INSTANCES["HPOLD"];
    }

    artobj.code = code;
    artobj.name["en-US"] = name;

    if (product_line) {
        var plobj = db.most.product_line.INSTANCES[product_line];
        if (plobj != null) {
            info("product line " + product_line + " found");
        } else {
            info("product line " + code + " not found. new instance");
            plobj = new db.most.product_line();
            plobj.code = product_line;
        }
        artobj.product_line = plobj;
    }

    if( description != null) {
        info("updating article descripion");
        artobj.description["en-US"] = description;    
    }
        
    if (artobj.vendor == null) {
        artobj.vendor = vendor;    
    }
    
    artobj.commit();
    return artobj;
}

var invobj = db.most.invoice_stock.INSTANCES[invoice_code];
var vendobj = db.contacts.vendor.INSTANCES[vendor];

if (invobj == null) {
    info("creating new invoice: " + invoice_code);

    invobj = new db.most.invoice_stock();
    invobj.code = invoice_code;
    invobj.name = invoice_no;
    invobj.vendor = vendobj;
//    invobj.contract = invoice_contract;
    invobj.invoice_date = PARSE_OPGDATE(invoice_date);
    invobj.purchase_order = purchase_order_no;
    invobj.import_time = java.date.today();
    invobj.total = net_invoice_price;
    invobj.description["en-US"] = "manual import from HP/XLS";
    invobj.commit();
} else {
    info("found invoice: " + invoice_no);
    if (invobj.description != "manual import from HP/XLS") {
        info("...is previously existing. not part of import. skipping");
        return;
    } 
}

var artobj = prod_find_or_create(article_code, article_code, product_line, "", vendor);
var opg = db.most.opg.INSTANCES[deal_id];

var stockobj;

// check if this is a serial number part of series of serials
if (serial_number != null && serial_number.length()) {
    stockobj = SDATA(invobj, "stocks", "stocks.article.id='" + artobj.id + "'");
    if (stockobj != null) {
        info("only add serial [" + serial_number + "] for article " + artobj.code);
        stockobj.serial_ids << serial_number;
        return;
    }
} 

// create new protocol entry if one was not resolved via serial
stockobj = new db.most.protocol_stock();
stockobj.invoice = invobj;
stockobj.bundle_number = bundle_id;
stockobj.quantity = quantity;
stockobj.article = artobj;
stockobj.price = PARSE_DOUBLE(price);
stockobj.total = PARSE_DOUBLE(price) * PARSE_INTEGER(quantity);

// add serial if this is the first creation of protocol_stock
if (serial_number != null && serial_number.length()) {
    info("adding serial [" + serial_number + "] to article " + artobj.code);
    stockobj.serial_ids << serial_number;
}

// try to find the corresponding OPG and set it
if (opg != null) {
  info("OPG resolved to " + deal_id);
  stockobj.opg = opg;
} else { 
  if (deal_id != null) { 
     info("could not resolve OPG " + deal_id);
  }
}

// convert the date to date object for the real/official date
var dtbrf = java.date.format("dd.MM.yyyy", invobj.invoice_date);
var dateobj = db.most.protocol_date.INSTANCES[dtbrf];
if (dateobj == null) {
    error("date obj not found"  + dtbrf);    
} else { 
    stockobj.real_date = dateobj;
    stockobj.official_date = dateobj;
    info("add position for: " + article_code + " of " + invoice_no);
}

stockobj.commit();

%>  ]]></value>
   </template>
   <header_row>
      <value>0</value>
   </header_row>
   <is_use_events>
      <value>true</value>
   </is_use_events>
   <is_archived>
      <value>false</value>
   </is_archived>
   <uuid>
      <value>1qLpEgPpQ8SprN9HeeIrqA</value>
   </uuid>
</object>
<!--  -->

</objects></import>
